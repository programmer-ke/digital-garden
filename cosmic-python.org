#+FILETAGS: :python:ddd:domain_driven_design:cosmicpython:
#+STARTUP: content

* Part 1
** Intro                 :big_ball_of_mud:DIP:depencency_inversion_principle:

- Software systems tend towards chaos and complexity, known as the
  "Big Ball of Mud" antipattern.
- Encapsulation and abstraction are key tools for maintaining order
  and simplicity in code.
- Layered architectures can help manage dependencies between code
  components.
- The Dependency Inversion Principle (DIP) is crucial for decoupling
  high-level business logic from low-level technical details.
- DIP states that high-level modules should depend on abstractions,
  not low-level modules.
- A Domain Model pattern can help keep business logic organized and
  maintainable.

** Domain Modeling                                             :domain_model:

- Unit testing the domain model can help describe the domain and
  define its interfaces

- Entities have long-lived identities and can change over time, while
  value objects are defined by their attributes and are usually
  immutable.

- Frozen dataclasses and tuples are great for value objects

- Entities classes can extend =__eq__= and =__hash__= for custom
  equality comparisons

- A domain service can be a function that performs a specific business
  operation, and doesn't have to be a class.

- Exceptions can be used to represent domain concepts, such as being
  out of stock, and should be named using the ubiquitous language of
  the business domain

** Repository Pattern                                            :repository:

- The Repository pattern is an abstraction over persistent storage
  that hides data access details.
- It allows decoupling the domain model from infrastructure concerns,
  making it easier to test and change.
- The pattern involves defining an interface (e.g.,
  AbstractRepository) and implementing it with a concrete class (e.g.,
  SqlAlchemyRepository).
- Using the Repository pattern makes it easy to create fake
  repositories for testing.
- The repository will typically have simple methods like =.add()=,
  =.get()= and which make it easier to decouple from underlying
  infrastructure.
  - ideally we handle one model at a time, delete is usually a
    soft-delete e.g. =batch.cancel()= and update is taken care of by
    the unit of work pattern

** Coupling and abstractions     :fcis:FCIS:functional_core_imperative_shell:

- To improve testability, simplify the interface between business
  logic and I/O by finding the right abstraction.
  - Use the Functional core imperative shell (FCIS) idea to
    separate what the system should do, and how it does it
- Prefer fakes over mocks for test doubles, as they represent working
  implementations. Fakes enable edge-to-edge testing which helps
  make high-level assertions about the code.
  - Mocks encourage a high coupling with infrastructure
- Design for testability means designing for extensibility, allowing
  for novel use cases.

** Service layer

- The service layer defines use-cases and orchestrates the workflows
  e.g. fetching required domain objects, making updates and commiting
  them, raising errors etc.
  - Distict from domain services e.g. a use case may involve calculating
    tax. The service layer will take care of fetching and assembling
    the required data and storing the results, but a domain service
    is responsible for the actual calculations.

- Depends on abstractions e.g. AbstractRepository instead of
  low level details.

- Allows more and faster unit tests to be written in an end-to-end
  fashion for use-cases e.g. using FakeRepository.  Reduces the need
  for a larger no of slower end-to-end tests across infrastructure
  layer.
  
- Sample package structure:
  
  + domain
    * model.py
  + service_layer
    * services.py
  + adapters
    * orm
    * repositories
  + entrypoints
    * flask_app.py
  + tests
    * unit
      - test_services.py
      - test_domain.py
    * integration
      - test_orm.py
      - test_repositories.py
    * e2e
      - test_flask_app.py

** TDD and the test pyramid

- Trade-off in tests:
  - API level tests:
    - Low feedback
    - Low barrier to change
    - High coverage
  - Domain level tests:
    - High feedback
    - High barrier to change
    - Low coverage

- Service layer tests strike the balance between:
  - High coverage
  - High feedback    
  - Low barrier to change

- To enhance decoupling of the service level tests:
  - Use primitive parameters for services
  - Use factories to populate fake repositories, or use a
    complementary service to add items to the repository
- Recommendations:
  - One end-to-end test per feature (API level)
  - Bulk of the tests against service layer
  - A small core of tests for the domain model (high feedback but more
    brittle)
  - If all errors are bubbled up and handled at the same place, one
    end-to-end test for failures can suffice.

** Unit of Work Pattern

- Abstracts atomic operations helping enforce data integrity and
  performance (single flush to the DB)
- Use of a context-manager makes it more Pythonic
- Promotes "Don't mock what you don't own" by abstracting away
  implementation details of session management
- Approaches: commit by default or rollback by default
  - Rollback by default makes the default safer - no changes unless
    explicitely committed

** Aggregates and Consistency Boundaries


- Aggregate :: a cluster of associated objects treated as a unit for
  the purpose of data changes e.g. a shopping cart with items
  - Analogous to an object that provides a public interface but hides
    private members
- We create one repository per aggregate
- Aggregates are in charge of one =consistency boundary=
  - Defined invariants and constraints apply to the whole aggregate e.g. serialized access.
- Two options for concurrency control for updates:
  - optimistic :: using version numbers. Assume success as default and
    retry failures for increased throughput
  - pessimistic :: Row-level locking e.g. using SELECT FOR UPDATE, or
    SERIALIZABLE transactions

* Part 2: Event Driven architecture - communicating across consistency boundaries

** Events and the Message bus

- Events help with the single-responsibility principle by making
  specific reactions generalizable around events and message
  handlers.
- A message bus routes messages to handlers
- Unit of Work collects events emitted by the domain and publishes
  them to the message bus

** Message Bus as entrypoint

- Instead of serving both the API and using handlers to respond to
  events, adopt a unified model where all inputs are events and
  services are event handlers. Events generated by services are
  retrieved by the message bus passed to appropriate handlers.
- Flow:
  - API request converted to domain event
  - Message bus selects appropriate service layer handlers for the event
  - Message bus collects any new events from unit of work
    - These are retrieved from the aggregate root
  - Message bus selects handlers for each of the new events
- Tests are written in terms of events

** Commands vs Events

- Introduce a distinction between commands and events:
  - commands :: imperative instructions e.g. allocate stock
  - events :: past tense facts e.g. stock allocated
- Commands handled by one actor and fail noisily
- Events can be handled by more than one actor and can fail
  independently without interrupting the flow
- The message bus now handles messages differently depending on
  whether they're commands or events

** Event driven architecture for microservices

- Designing microservices around nouns like orders, batches,
  shipments etc creates high coupling (ball of mud):
  - execution coupling/connascence :: Calls across microservices for
    the happy path have to happen in a particular order. Handling
    exceptional conditions happens in a different order.
  - temporal coupling/connascence :: different services have to be
    available at the same time, otherwise a single service failure can
    result in cascading failure.
- Instead, designing microservices around consistency boundaries
  e.g. ordering, allocating etch can allow use of asynchronous
  messaging with eventual consistency across consistency boundaries
- Message brokers like Redis and RabbitMQ can be used for microservice
  communication.
- Choices around message reliability like at least once or at most
  once delivery needs consideration.

** Command-Query Responsibility segregation

- Recognizing that the domain model is optimized for writing, we can
  separate read and writes.
  - Similar to the POST/redirect/GET pattern in web dev
- Options with different trade-offs:
  - Add read methods to repositories
  - use custom queries via the ORM or raw SQL to query normalized schema
  - Add denormalized tables for the read operations (e.g. using views)
  - Create a different read store e.g. on Redis that is updated view
    update events from the domain model
      
** Dependency Injection

- Instead of creating dependencies in the entrypoints, a bootstrap
  mechanism can be used where the handlers can be returned with
  already injected dependencies.
- Two approaches:
  - use lambda or partial functions
  - Use classes that are initialized with required dependencies
