#+FILETAGS: :unix:
#+STARTUP: content

* Unix Overview

* The Unix Programming Environment
** overview

*** Terminal and shell interaction                           :terminal:shell:
(from llama4)

1. Terminal emulator creates a new pseudo-terminal (PTY) pair.
2. Forks a new process, which becomes the shell (e.g., =bash=, =zsh=).
3. The child process (shell) is connected to the PTY slave device.
4. The terminal emulator process (parent) is connected to the PTY
   master device.


Here's a simple representation:

- Terminal Emulator (parent)
	+ Forks â†’ Shell (child)
		- Connected to PTY slave
	+ Remains connected to PTY master, displaying output and
          receiving input

The shell then runs in the terminal, reading input from the user,
executing commands, and displaying output.

*** I/O model
- Most commands take input from a file or read the standard input.
- Output is sent to the standard output
- Error messages are sent to the standard error
- Pipes are used to connect programs  
- Input can be redirected from a file or received through a pipe
- Output can be redirected to a file or sent to a pipe

*** commands
date, who, mail, stty, ed, ls, cat, pr, mv, rm, wc, sort, tail, cmp,
diff, pwd, grep, cd, rmdir, echo, nohup, at, kill

** The File System                                         :files:filesystem:
*** Detecting EOF                                        :setuid:set:uid:eof:
  - There's no special character to represent end of a file
  - The =read= kernel subroutine used to read from files returns the
    number of bytes read
  - When the bytes read is zero, end-of-file is assumed
  - ctrl-d sends all currently pending input to the program. If
    there's no pending input, the program assumes end of file
    e.g. logging out of the shell using ctrl-d

- Unix defaults to text file formats with no assumptions except
  newline termination
  - Makes programs interoperable
  - Avoids the need for specialized set of programs for each file format
- The current working directory is a property of each running process
  in the system
- Each logged in user is assigned a user id and group id
  - Relevant files: =/etc/passwd= and =/etc/group=
- The =set-uid= bit e.g. on the =passwd= command allows any user
  executing a program run it as the program's owner (allowing users to
  change own passwords).
- A directory is a file that is written to using special system routines
- Directory permissions are different from file permissions:
  - read permission allow listing directory contents
  - write permission allow adding/removing directory content
  - execute permission allows searching directory content

*** Inodes                                                     :inode:inodes:

- An inode is an entry to a table that stores file metadata such as
  name, time created or modified, length of the file, location of the
  file, etc
- =ls -i= show a files inode number
- =ln= creates a different link to the file (different name for same
  file).  A file is deleted when it has zero links. (inode is shared)
- =mv= changes the existing file link (name) (inode remains the same)
- =cp= creates a new file with identical content as the original file
  (new inode and link created)

*** Devices

- Peripheral devices are represented as files in the /dev subdirectory.
  - Instead of special routines to access these devices, programs read
    from and write to them as files
  - In the kernel, references to the device files are translated to
    hardware commands
  - =ls -l= shows the type of device (character or block) as the first
    character of the mode
  - The mount command shows mapping of storage devices to directories
- the =tty= command shows the user's current controlling terminal in /dev
  - =mesg= can be used to alter permissions on the terminal e.g. to
    allow/disallow other users from sending messages via =talk= or
    =write=
  - =/dev/tty= is a synonym for a user's controlling terminal that
    programs can use to send messages
- writing to =/dev/null= discards the data and reading from it gives
  zero bytes.

*** commands
od, du, crypt, ls -c, ls -u, ls -t, ls -i, tty, mesg, write
      
** The Shell                                                          :shell:
*** Command line structure

- =;= terminates commands
- =()= group commands
- =|= creates a pipeline and has a higher precedence than =;=
  - =date; who | wc= has pipeline taking precedence
  - =(date; who) | wc=  has =;= taking precedence

- =&= terminates command without waiting for output, turns it into a
  background job
- =tee= copies input to a named file as well as its output
- the various special characters like =;, >, <, |, &= are interpretted
  by the shell and not sent to programs as arguments. The following
  are equivalent:
  - =echo hello >junk=, =>junk echo hello=.
    - The program =echo= never sees =>=

*** Metacharacters      
- Special characters that are interpreted by the shell before
  executing commands
- Their interpretation can be escaped using quotes or backslashes
- Single and double quotes escape each other
  
*** Creating new commands
- chmod x makes files executable by the shell
- custom programs are set in PATH to be discoverable
- $1 to $9 matches the (upto 9) arguments to a command
- $* matches all the arguments provided
- $0 is the name of the command itself being executed by the subshell
- backtics allow a program's output be used as arguments

*** Shell variables

- Defined for the current shell and not accessible in sub shells
  unless exported
- the =.= operator can be used to read commands from a file to execute
  in the current shell without using a sub shell
- Variables can be temporarily exported to sub shells by declaring
  them inline before the command

*** I/O Redirection                                             :redirection:

- Every program has 3 file descriptors by default when it starts,
  standard input, standard output and standard error, represented by
  number 0, 1 and 2 respectively
- n>filename redirects the output from the file descriptor n to filename
- n>&m merge output from file descriptors n and m
- n<&m merges the input from file descriptor n with m
- the =here document= construct can be used to specify the standard
  input of a program along with the program itself
  #+begin_src bash
  wc -l <<End
  once upon a time,
  there were 3 little bears
  End
  #+end_src

*** Looping                                                             :for:

- use the =for= statement:

#+begin_src bash
for i in *
do
	     echo $i
done
#+end_src

- =do= and =done= appear either at the start of a line or after a semi-colon:

#+begin_src bash
for i in *; do echo $i; done
#+end_src

output of the for loop can be redirected/piped.

** Filters
*** grep family                                                        :grep:
- for each input line matches a pattern defined as a regular
  expression and prints it as output
- grep :: matches ed's regular expressions
- egrep :: supports more general expressions like or with | and
  parentheses
- fgrep :: supports parallel searching of patterns but without
  metacharacter support
- =egrep= and =fgrep= support -f flag to search patterns specified in
  a file in parallel
*** Other filters
- sort, comm, tr, uniq, dd
*** sed
- A streaming version of ed (stream editor) that supports ed's commands
- A more general grep like tool that performs an action (print, delete, write etc)
  on lines that match certain patterns
- Sample commands:
 `sed 'commands' filenames` - Apply commands to files
 `sed -f cmdfile filenames` - Read commands from file
 `sed -n` - Suppress automatic printing (use with `p`)
 `sed '20,30p'` - Print lines 20-30 (with `-n`)
 `sed '1,10d'` - Delete lines 1-10
 `sed '/pattern/d'` - Delete lines containing pattern
 `sed '/pattern/!d'` - Delete lines NOT containing pattern
 `sed '/^$/,/^end/p'` - Print from empty line to line starting with "end"
 `sed '$d'` - Delete last line
 `s/old/new/` - Substitute first occurrence in line
 `s/old/new/g` - Substitute all occurrences in line
 `s/old/new/p` - Print line if substitution made
 `s/old/new/w file` - Write changed lines to file
- Limitations of sed:
  - limited memory, makes only one pass, no forward references, no
    manipulation of numbers (pure text processor)
*** awk
- fixes some of the limitations of =sed=
- has the same form =awk 'program' filenames..=
- program can be a sequence of instructions in the following form
  sequencially performed on each line:
  
  =pattern { action }=
  =pattern { action }=

- Either of pattern and action is optional. When no pattern is
  specified, it matches all lines. When no action is specified,
  the default is to print matched lines
- By default, lines are broken into fields divided by whitespace.
  - Each is assigned to variables $1 to $NF. NF is the number of fields
  - A single character separator can alternatively be specified with option =-F=
- =print= and =printf= can be used for printing.
  -  =print= simply outputs comma separated fields separated by the
    default whitespace separator
- BEGIN actions are perfomed before processing the first line.
- END actions are performed after processing all the lines
- Richer filter functionality includes arithmetic, conditionals, control flow,
  arrays, associative arrays

** Shell Programming
** Programming with Standard I/O
** Unix System Calls
** Programs Development
** Document Preparation
