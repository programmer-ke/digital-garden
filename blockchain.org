#+FILETAGS: :blockchain:web3:ethereum

* Sybil attack                                                        :sybil:

A single actor creating multiple pseudonomous identities in a
distributed system to gain outsized influence over it.

* Proof of Work                        :pow:proof_of_work:longest_chain_rule:

- A block contains a list of transactions and a hash of the previous block
- Miners compete to generate a hash of the block that contains the:
  - hash of the previous block
  - The transaction hashes of the current block
  - A nonce value
- The goal is to find a block hash that meets a certain computational difficulty
  threshold (a given amount of leading zeroes)
  - A hash is random so this involves billions or trillions of attempts
  - Miners try different nonce values to get a hash that meets the difficulty threshold
- The longest valid chain is considered the true state of the blockchain
- A fork occurs when there are two or more miners who have the longest
  valid chains with different heads. When this happens, the first one
  to find the next valid block is considered the source of truth
- Once a transaction is added into a valid block it is confirmed. Every valid
  block added after it generates an additional confirmation.
- In bitcoin, once a transaction has received 6 confirmations it is
  considered irreversible, because an astronomical amount of energy is
  required to reverse six blocks. This is called probalistic finality.
- A malicious attacker who wants to modify the state of the blockchain
  would have to generate new hashes from the point of time of
  alteration. They would only be successful if they control over 50%
  of the network's hashing power.


* ECDSA Signatures for ethereum transaction :EDSA:ecdsa:elliptic_curve:cryptography:signature:

1. Generate a 12 seed phrase
2. Generate private keys:
   - From the seed phrase, a sequence of private keys can be
     deterministically
3. For each private key, generate a public key using eliptical curve crytography:
   - This is a one-way operation
4. For each public key, generate a shorter, user-friendly address
5. Sender signs an ethereum transaction using the private key
   - transactions contains fields such as =to=, =value=, =nonce=
6. The blockchain verifies the transaction using the signer's public
   key, the original message and the signature

* Proof of Stake                             :pos:proof_of_stake:attestation:

- A user becomes a validator by staking a minimum of 32ETH
- The PoS protocol pseudo-randomly selects a validator to propose a
  new block during a specific time interval (12 seconds in ethereum)
- The chosen validator signs a block containing the transaction hashes
  and a hash of the previous block
- A committee of other validators are chosen to review its validity and vote on
  including it in the chain. This is called =attestation=
- For the block to be valid, it needs to receive attestations from at least
  2/3 of the total staked voting power. Once it receives this, it becomes =justified=.
- When the next block is also justified, the block now becomes
  =finalized= as a permanent immutable part of the blockchain history
- If a validator is proven to have behaved maliciously, its staked ETH
  is slashed i.e. burned in part or completely, and could be removed
  from the network. This incentivizes good behaviour
- A well-behaved validator is rewarded for their participation in
  generating blocks.
- The more value of ETH staked in securing the network, the more
  expensive it becomes for an attacker to control it.

* Common blockchain vulnerabilities :sybil_attack:51%_attack:fork_choice_algorithm:mev:replay_attack:

- Sybil attack :: A malicious actor creating multiple fake identities
  or nodes in a distributed system to subvert it e.g. approve malicious transactions
- 51% attack :: Gaining majority control over the hashrate in a PoW
  chain or controlling majority stake in a PoS chain
  - Majority control in a PoW chain allows one to rewrite history
  - Majority control in a PoS chain like ethereum allows one to control the =fork
    choice algorithm= that decides the canonical state of the
    blockchain. Controlling 2/3 of the staked ETH would
    allow an actor to rewrite blockchain history
- Blockchain Reorganization :: Attacks exploiting temporary forks of a
  PoW chain when different miners finalize different blocks around the
  same time, hence the importance of waiting for multiple
  confirmations for finality.
- MEV and Sandwich Attacks :: Exploiting the order of transactions by
  front-running then back-running transactions submitted to the
  mempool, making profit through slippages.
- Client bugs :: Exploiting bugs in the client software executed on nodes
- Replay Attacks :: Re-broadcasting a valid, signed transaction in the
  same chain, or a different compatible chain e.g. an L2
  - Prevented by signing along with the transaction an every
    increasing nonce from a single account and the chain id

* Gas Fees                                                 :gas_fees:eip1559:

** Type 0: Legacy

- Used a first-price auction model:
  - gas price :: price in wei willing to pay for gas
  - gas limit :: Maximum amount of gas willing to let the transaction consume
- Unpredictability, as it resulted in people overpaying for inclusion and transaction stuck for days during congestion.

** Type 2: EIP-1559 Transactions  

- Makes price more predictable by use of:
  - base fee :: determined algorithmically based on the previous
    block, adjusted up or down based on whether the previous block was
    more than 50% or not. It is burned making ETH supply deflationary
  - priority fee :: Optional fee paid directly to the validator to
    prioritize transactions within the same block
    
* Transaction lifecycle                               :transaction_lifecycle:

** Process

- User signs a transaction, it is submitted to the mempool, added to a
  block and the block is added to the chain
- User generates signature of a hash of the transaction data. The transaction data
  includes nonce, chain id, gas params, transaction details
  - The wallet forwards the transaction to a node via an RPC endpoint
- The node validates the transaction data hash, signature, account balance etc then adds
  the transaction to its mempool, and distributes it to other nodes. Each node does the
  same on receiving the transaction
- Every 12 seconds a node is selected to propose a block. It selects transactions from its
  mempool starting from the ones with the highest priority fees and executes each transaction
  (altering the local blockchain state) and adds it to the block.
  - After transactions are added, the node signs the block and
    propagates it to the rest of the network
- An attestation committee validate the block by executing each
  transaction and confirming the blockchain end state. If 2/3 of the
  committee attest the block is it considered confirmed and added to the blockchain.
- A block is considered final when 2/3 of all active validators attest it.

** Transaction states

- pending :: added to the mempool
- confirmed / success :: added to a block
- finalized :: Added to the chain
- reverted :: Added to block but execution failed (state rolled back but gas consumed)
- dropped :: removed from the mempool (too low gas fee or higher priority transaction with same nonce)

* Account abstraction

Currently there are two account types on ethereum:

- Externally Owned Accounts (EOA) :: Controlled by private keys and
  can initiate transactions.
- Smart contract accounts :: Not controlled by private keys, instead
  they are programmable. However, they cannot initiate transactions

Account abstraction abstracts away the distinction between the two
combining their advantages by use of =smart wallets=.
