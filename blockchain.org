#+STARTUP: content
#+FILETAGS: :blockchain:web3:ethereum

* Sybil attack                                                        :sybil:

A single actor creating multiple pseudonomous identities in a
distributed system to gain outsized influence over it.

* Proof of Work                        :pow:proof_of_work:longest_chain_rule:

- A block contains a list of transactions and a hash of the previous block
- Miners compete to generate a hash of the block that contains the:
  - hash of the previous block
  - The transaction hashes of the current block
  - A nonce value
- The goal is to find a block hash that meets a certain computational difficulty
  threshold (a given amount of leading zeroes)
  - A hash is random so this involves billions or trillions of attempts
  - Miners try different nonce values to get a hash that meets the difficulty threshold
- The longest valid chain is considered the true state of the blockchain
- A fork occurs when there are two or more miners who have the longest
  valid chains with different heads. When this happens, the first one
  to find the next valid block is considered the source of truth
- Once a transaction is added into a valid block it is confirmed. Every valid
  block added after it generates an additional confirmation.
- In bitcoin, once a transaction has received 6 confirmations it is
  considered irreversible, because an astronomical amount of energy is
  required to reverse six blocks. This is called probalistic finality.
- A malicious attacker who wants to modify the state of the blockchain
  would have to generate new hashes from the point of time of
  alteration. They would only be successful if they control over 50%
  of the network's hashing power.


* ECDSA Signatures for ethereum transaction :EDSA:ecdsa:elliptic_curve:cryptography:signature:

1. Generate a 12 seed phrase
2. Generate private keys:
   - From the seed phrase, a sequence of private keys can be
     deterministically
3. For each private key, generate a public key using eliptical curve crytography:
   - This is a one-way operation
4. For each public key, generate a shorter, user-friendly address
5. Sender signs an ethereum transaction using the private key
   - transactions contains fields such as =to=, =value=, =nonce=
6. The blockchain verifies the transaction using the signer's public
   key, the original message and the signature

* Proof of Stake                             :pos:proof_of_stake:attestation:

- A user becomes a validator by staking a minimum of 32ETH
- The PoS protocol pseudo-randomly selects a validator to propose a
  new block during a specific time interval (12 seconds in ethereum)
- The chosen validator signs a block containing the transaction hashes
  and a hash of the previous block
- A committee of other validators are chosen to review its validity and vote on
  including it in the chain. This is called =attestation=
- For the block to be valid, it needs to receive attestations from at least
  2/3 of the total staked voting power. Once it receives this, it becomes =justified=.
- When the next block is also justified, the block now becomes
  =finalized= as a permanent immutable part of the blockchain history
- If a validator is proven to have behaved maliciously, its staked ETH
  is slashed i.e. burned in part or completely, and could be removed
  from the network. This incentivizes good behaviour
- A well-behaved validator is rewarded for their participation in
  generating blocks.
- The more value of ETH staked in securing the network, the more
  expensive it becomes for an attacker to control it.

* Common blockchain vulnerabilities :sybil_attack:51%_attack:fork_choice_algorithm:mev:replay_attack:

- Sybil attack :: A malicious actor creating multiple fake identities
  or nodes in a distributed system to subvert it e.g. approve malicious transactions
- 51% attack :: Gaining majority control over the hashrate in a PoW
  chain or controlling majority stake in a PoS chain
  - Majority control in a PoW chain allows one to rewrite history
  - Majority control in a PoS chain like ethereum allows one to control the =fork
    choice algorithm= that decides the canonical state of the
    blockchain. Controlling 2/3 of the staked ETH would
    allow an actor to rewrite blockchain history
- Blockchain Reorganization :: Attacks exploiting temporary forks of a
  PoW chain when different miners finalize different blocks around the
  same time, hence the importance of waiting for multiple
  confirmations for finality.
- MEV and Sandwich Attacks :: Exploiting the order of transactions by
  front-running then back-running transactions submitted to the
  mempool, making profit through slippages.
- Client bugs :: Exploiting bugs in the client software executed on nodes
- Replay Attacks :: Re-broadcasting a valid, signed transaction in the
  same chain, or a different compatible chain e.g. an L2
  - Prevented by signing along with the transaction an every
    increasing nonce from a single account and the chain id

* Gas Fees                                                 :gas_fees:eip1559:

** Type 0: Legacy

- Used a first-price auction model:
  - gas price :: price in wei willing to pay for gas
  - gas limit :: Maximum amount of gas willing to let the transaction consume
- Unpredictability, as it resulted in people overpaying for inclusion and transaction stuck for days during congestion.

** Type 2: EIP-1559 Transactions  

- Makes price more predictable by use of:
  - base fee :: determined algorithmically based on the previous
    block, adjusted up or down based on whether the previous block was
    more than 50% or not. It is burned making ETH supply deflationary
  - priority fee :: Optional fee paid directly to the validator to
    prioritize transactions within the same block
    
* Transaction lifecycle                               :transaction_lifecycle:

** Process

- User signs a transaction, it is submitted to the mempool, added to a
  block and the block is added to the chain
- User generates signature of a hash of the transaction data. The transaction data
  includes nonce, chain id, gas params, transaction details
  - The wallet forwards the transaction to a node via an RPC endpoint
- The node validates the transaction data hash, signature, account balance etc then adds
  the transaction to its mempool, and distributes it to other nodes. Each node does the
  same on receiving the transaction
- Every 12 seconds a node is selected to propose a block. It selects transactions from its
  mempool starting from the ones with the highest priority fees and executes each transaction
  (altering the local blockchain state) and adds it to the block.
  - After transactions are added, the node signs the block and
    propagates it to the rest of the network
- An attestation committee validate the block by executing each
  transaction and confirming the blockchain end state. If 2/3 of the
  committee attest the block is it considered confirmed and added to the blockchain.
- A block is considered final when 2/3 of all active validators attest it.

** Transaction states

- pending :: added to the mempool
- confirmed / success :: added to a block
- finalized :: Added to the chain
- reverted :: Added to block but execution failed (state rolled back but gas consumed)
- dropped :: removed from the mempool (too low gas fee or higher priority transaction with same nonce)

* Account abstraction                                   :account_abstraction:

Currently there are two account types on ethereum:

- Externally Owned Accounts (EOA) :: Controlled by private keys and
  can initiate transactions.
- Smart contract accounts :: Not controlled by private keys, instead
  they are programmable. However, they cannot initiate transactions

Account abstraction abstracts away the distinction between the two
combining their advantages by use of =smart wallets=.

* Blockchain Use Cases

** Defi                                                   :defi:aave:farming:

- Decentralized Exchanges (DEXs) e.g. Uniswap and Curve
- Lending and Borrowing e.g. Aave and Compound
- Derivatives and Trading Platforms e.g. GMX
- Yield Farming and Liquidity Mining
- Asset Management e.g. Yearn Finance

Example of composability:

- Deposit eth into Aave to earn interest and receive an
  interest-bearing token
- Use the interest bearing token as collateral in another protocol to
  borrowing a stable coin
- Deposit the stable coin in a liquidity pool on a DEX like Uniswap

User now earns both interest in the original lending yield from Aave
plus a share of trading fees from Uniswap

** Tokens                                                            :tokens:

*** Categories                                                     :nft:NFTs:

- Native Tokens :: primary currency associated with a given network
  used for gas fees, transactions, security (PoS) and governance
  (voting)

- Fungible Tokens :: These are interchangeable and divisible. In
  Ethereum, they're mostly based on the ERC20 standard. Native tokens
  are also fungible.

- Non-Fungible Tokens :: unique, non-interchangeable and
  indivisible. Each has a unique ID and associated metadata. In
  Ethereum they are mostly based on ERC721

- Semi-Fungible Tokens :: a hybrid between fungible and non-fungible
  where identical copies of a token type can exist, but are not
  interchangeable across types

*** Tokenization of Real-World Assets (RWAs)                            :rwa:

- Creating tokens that represent a ownership of a physical or tradfi
  asset.

*** Stable Coins                                                :stablecoins:

Provide a reliable medium of exchange and store of value without
volatility associated with other cryptocurrencies

- Fiat-Backed Stablecoins :: Backed by fiat held in a
  reserve. Centralized and can be frozen
- Crypto-Backed Stablecoins :: Backed by over-collateralized crypto
  held in a smart contract. The value of the locked crypto is higher
  than the stablecoins issued. Decentralized and cannot be frozen
- Algorithmic stablecoins :: Use of complex algorithms and market
  mechanisms to automatically manage supply to maintain their price
  peg.

** Exchanges

*** Centralized Exchanges

- Custodial (managed) accounts that require KYC
- Orders are performed by an order book, matching buyers and sellers at set prices
- Good for onramp from fiat and offramp into fiat
- Smoother user experience, high liquidity hence less volatility
- Major disadvantage is =custodial risk=, reliance on the exchange's
  solvency and security.

*** Decentralized Exchanges

- Self-custody with no KYC
- Exchange is via Automated Market Makers, trade happens in liquidity
  pools instead of with another person.
- Requires secure private key management to retain funds
- Main risk is =smart contract risk= bugs in the smart contract code
  can have people lose funds to attackers.

** Decentralized Governance                                         :dao:DAO:

- Distributed governance via Decentralized Autonomous Organizations
  (DAOs).
- Advantages like skin in the game and distributed decision making
- Disadvantages include voter apathy, whales re-centralizing control
  and technical complexity


* Layer 1, Layer 2 and Rollup Scaling solutions

- The blockchain trilema :: Blockchains can only optimize for 2 of
  decentralization, security and scalability.

- The Ethereum blockchain focuses on decentralization and security,
  therefore scalability can be a bottleneck leading to high
  transaction costs and congestion

** L1

A layer one is an independent blockchain protocol responsible for
attaining concensus on the state of the ledger achieving finality and
security without relying on any other network.

** L2

A layer two is a protocol built on a L1 inheriting its security and
decentralization properties and providing higher scalability.

*** Rollups

This is the most widely used l2 scaling solution. It works by
executing transactions off the l1 chain then bundling them (rolling
them up) into a single compressed batch and posting them to the l1.

Two primary types:

**** Optimistic Rollups

- Operates on the principle that all the transactions in the batch are
  valid.
- When an operator submits a batch to the l1, any other network
  participant can provide a fraud proof of an invalid transaction
  within a week.
- If one is found, the transaction batch is reverted and the operator
  penalized, otherwise the transactions are finalized.

**** Zero Knowledge Rollups

- Whenever a transaction batch is submitted by an operator to the L1, and
  accompanying cryptographic Zero-Knowledge proof is provided to show that the
  transactions are all valid.
- A smart contract called a verifier instantly checks this proof and
  if it is valid, immediately finalizes the transaction batch.

*** Centralized Sequencers, a single point of failure in Blockchain Rollups

- A sequencer is an operator responsible for maintaining the order of
  transaction submitted by users in L2s and in some cases bundling
  them before they are submitted to L1s
- For simplicity and efficiency, they tend to be centralized but this
  introduces some problems:
  - A malicious sequencer can censor transactions or re-order them for
    their own benefit e.g. front-running transactions
  - An unreliable sequencer can prevent the transactions from being
    submitted to the L1 resulting in a DoS
- Most early stage L2s have centralized sequencers, but efforts are
  underway to decentralize the sequencer role.

*** A framework for L2 Maturity: Rollup Stages

Analysis platform [[https://l2beat.com/scaling/summary][L2BEAT]] tracks L2s progress in maturing from Stage 0
to Stage 2.
